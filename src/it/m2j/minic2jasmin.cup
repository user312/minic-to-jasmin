import java_cup.runtime.*;
import java.util.HashMap;

//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/*--------------------------------PARSER CODE ----------------------------------*/
parser code {:
	/* Symbol table for type checking */
    HashMap<String,SymbolType> symbolType_table = new HashMap<String,SymbolType>();

	// Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
    
    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    
:};

/*--------------------------------ACTION CODE ----------------------------------*/
action code {:

	/* Class used to store expression and to do type checking on expressions */
    class Expr{
        private String value;
        private SymbolType type;

        private SymbolType lookupSymbolType(String id){
            SymbolType type = parser.symbolType_table.get(id);
            if (type == null){
                pSemError("Variable \""+id+"\" not declared");
                return new SymbolType(IdType.NULL, IdType.NULL);
            }
            return type;
        }
        
        Expr(String value, SymbolType type){
            this.value = value;
            this.type = type;
        }
        Expr(String id){
            this.value = id;
            this.type = lookupSymbolType(id);
        }

        Expr(String id, Integer pos){
            this.value = id+"["+pos.toString()+"]";
            this.type = lookupSymbolType(id);

            int dim = type.getDim();
            if (pos>=dim && dim!=-1){
                pSemError("Array index ("+pos+") exceed array size ("+dim+")");
            }
        }
        Expr(String id, String pos){
            this.value = id+"["+pos+"]";
            this.type = lookupSymbolType(id);

        }


        public String toString(){
            return value;
        }
        public SymbolType getSymbolType(){
            return type;
        }

        /* Check symbol type. In return unknown type in the case of type error */
        public SymbolType checkSymbolType(Expr expr){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();

/* TODO: rivedere il controllo di expr fra tipi diversi
            if (type1==type2){
                return type;
            }else if(type1!=-1 && type2!=-1){
                // If operands are of two different types cast them to double 
                pSemWarning("Operation between int and double, int number casted to double");
                return new SymbolType(1, 1);
            }else{
                return new SymbolType(IdType.NULL, IdType.NULL);
            }
*/
  			return new SymbolType(IdType.NULL, IdType.NULL); //Rimuovere dopo TODO
        }
        /*public void checkSymbolTypeAssignment(Expr expr){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();

            if (type1==0 && type2==1){
                pSemWarning("Assignment of a double value to an int variable");
            } else if (type1==1 && type2==0){
                pSemWarning("Assignment of an int value to an double variable");
            }
        }*/
    }
	
 	// Error management
    private void pSemError(String message){
        System.err.println("SEM ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        parser.done_parsing();
    }
    private void pSemWarning(String message){
        System.err.println("SEM WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
    }
    private void pSynError(String message){
        System.err.println("SYN ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        parser.done_parsing();
    }
    private void pSynWarning(String message){
        System.err.println("SYN WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        /* Quando c'Ã¨ un errore sintattico continuo il parsing ma disabilito la semantica */
        //disableSem();
    }    
:}

/*--------------------------------TERMINAL / NON TERMINAL ----------------------------------*/
// Terminal tokens
terminal TYPE_BOOL, TYPE_INT, TYPE_STRING, TYPE_VOID, TYPE_FLOAT;
terminal EXTERN;
terminal IF, ELSE, WHILE;
terminal ASSIGN, NEW, RETURN;
terminal OP_PLUS, OP_DIFF, OP_TIME, OP_DIV, OP_MOD, OP_SIGN;
terminal OP_EQ, OP_NEQ, OP_LT, OP_LET, OP_GT, OP_GET, OP_AND, OP_OR, OP_NOT;
terminal COMMA, SEMI;
terminal BRA_O, BRA_C, BRA_OS, BRA_CS, BRA_OG, BRA_CG;

terminal String ID;
terminal Bool CONST_BOOL;
terminal Integer CONST_INT;
terminal Float CONST_FLOAT;
terminal String CONST_STRING;

// Non terminal tokens
non terminal prog, stmt_list, stmt, if, while, assign_stmt, print;
non terminal Integer[] nt0_while;
non terminal Integer nt0_if, nt1_if;
non terminal /*String*/ Expr expr;
//non terminal minug, magug;
non terminal ret_stmt, if_then_stmt, if_then_else_stmt, while_stmt;
non terminal expr_list;

non terminal function, func_list, func_def, func_def_ext, decl_list, decl, var_list, var, decl_param, formal_param, func_call;
non terminal block, block_in, ret_type, param_list, decl_param_list;
non terminal String type, simple_type, array_dim, array_index;
non terminal String if_condition, while_condition;
non terminal /*String*/Expr id;

/*--------------------------------PRIORITY / ASSOCIATIVITY ----------------------------------*/
//lower priority
precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQ, OP_NEQ;
precedence nonassoc OP_NOT;
precedence left OP_LT, OP_LET, OP_GT, OP_GET;
precedence left OP_PLUS, OP_DIFF;
precedence left OP_TIME, OP_DIV, OP_MOD;
precedence nonassoc OP_SIGN;
//highest priority

/*-------------------------------- GRAMMAR ----------------------------------*/
start with prog;

prog ::= func_list
        ;

decl ::= type var_list                          
        ;

type ::= simple_type:x 				{: RESULT=x; :}                                       
     	| simple_type:x array_dim   {: RESULT=x; :}                          
     	;

simple_type ::= TYPE_BOOL		{: RESULT = new String("BOOL"); :}
        | TYPE_INT				{: RESULT = new String("INT"); :}
        | TYPE_FLOAT			{: RESULT = new String("FLOAT"); :}
        | TYPE_STRING			{: RESULT = new String("STRING"); :}
        ;

array_dim ::= BRA_OS BRA_CS
        | array_dim BRA_OS BRA_CS                       
        ;

var_list ::= var
       	| var_list COMMA {: RESULT = parser.stack(-2); :} var
       	| var_list var /* error */		{: pSynWarning("Missing ',' before identifier"); :}	
       	;

var ::= ID:x 		{: if(parser.stack(-1).equals("INT"))
           			 					parser.symbolType_table.put(x, new SymbolType(IdType.INT)); 
           			 				else if (parser.stack(-1).equals("FLOAT"))
           			 					parser.symbolType_table.put(x, new SymbolType(IdType.FLOAT));
           			 				else if (parser.stack(-1).equals("BOOL"))
           			 					parser.symbolType_table.put(x, new SymbolType(IdType.BOOL));
           			 				else if (parser.stack(-1).equals("STRING"))
           			 					parser.symbolType_table.put(x, new SymbolType(IdType.STRING));
           			 			:}
        ;

func_list ::= /* empty */
       	| func_list function
       	;

function ::= func_def block       
		| EXTERN func_def_ext SEMI					
		;

func_def_ext ::= CONST_STRING ret_type ID BRA_O block_in decl_param BRA_C                               			          		
        ;

func_def ::= ret_type ID BRA_O block_in formal_param BRA_C
		| ret_type ID block_in formal_param /* error */ 		{: pSynWarning("Error in function definition "); :}
        ;

formal_param ::= TYPE_VOID
	    | /* empty */
        | param_list                                 
        ;
            
decl_param ::= TYPE_VOID                            
	    |/* empty */											
		| decl_param_list                             
        ;

param_list ::= type var                                     
		| param_list COMMA type var                     
		| param_list type var /* error */ 		{: pSynWarning("Missing ',' before identifier"); :}            
    	;
          
decl_param_list ::= type                                    
        | decl_param_list COMMA type                    
        ;

ret_type ::= TYPE_VOID                                  
        | type                                       
        ;

block_in ::= /* empty */   //controllo EOF (da rivedere)                               
		;

block ::= BRA_OG stmt_list BRA_CG
		| BRA_OG stmt_list error BRA_CG			{: pSynWarning("Missing ';' before }"); :}  
		| BRA_OG error BRA_CG					{: pSynWarning("Missing ';' before }"); :}             
		;

stmt_list ::= /* empty */ //controllo EOF (da rivedere)                    
		| stmt_list stmt                 
        ;

stmt ::= block_in block                              
		| decl SEMI	       		
		| decl error            {: pSynWarning("Missing ';' in statement"); :}
		| func_call SEMI 		
		| func_call error		{: pSynWarning("Missing ';' in statement"); :}                          
		| assign_stmt                             
		| ret_stmt                             
		| if_then_stmt                             
		| if_then_else_stmt                         
		| while_stmt                              
		| error SEMI			{: pSynWarning("Error in statement"); :}       
        ;

assign_stmt ::= id ASSIGN expr SEMI            
		| id array_index ASSIGN expr SEMI  
		| id ASSIGN error SEMI				{: pSynWarning("Error in expression"); :}
		| error ASSIGN expr SEMI 			{: pSynWarning("Error in assigment"); :}
        ;

array_index ::= BRA_OS expr BRA_CS 
        | error BRA_CS 					{: pSynWarning("Error in vector"); 	:} 
		| array_index BRA_OS expr BRA_CS  		      
        ;

func_call ::= ID BRA_O /* no params */ BRA_C     // gestire id di function      
		| ID BRA_O expr_list BRA_C            
        ;

ret_stmt ::= RETURN expr SEMI                
        ;

if_then_stmt ::= IF if_condition block_in block          
        ;

if_then_else_stmt ::= IF if_condition block_in block ELSE block_in block
		| IF if_condition block_in block error block_in block		{: pSynWarning("Error 'else' expected in 'if' instruction"); :}	             
        ;
        
if_condition ::= BRA_O expr BRA_C 
    	| BRA_O error BRA_C			{: pSynWarning("Error in 'if' condition"); :}
    	| error expr BRA_C 			{: pSynWarning("Error '(' expected in 'if' instruction"); :}
    	| BRA_O expr error  		{: pSynWarning("Error ')' expected in 'if' instruction"); :}
		;

while_stmt ::= WHILE while_condition block_in block         
        ;

while_condition ::= BRA_O expr BRA_C 
    	| BRA_O error BRA_C			{: pSynWarning("Error in 'while' condition"); :}
    	| error expr BRA_C 			{: pSynWarning("Error '(' expected in 'while' instruction"); :}
    	| BRA_O expr error  		{: pSynWarning("Error ')' expected in 'while' instruction"); :}
		;

expr_list ::= expr                             
        | expr_list COMMA expr        
        ;

expr ::= expr OP_PLUS expr              
        | expr OP_DIFF expr              
        | expr OP_TIME expr              
        | expr OP_DIV expr               
		| OP_DIFF expr %prec OP_SIGN           
        | expr OP_AND expr               
        | expr OP_OR expr                
        | OP_NOT expr                          
        | BRA_O TYPE_INT BRA_C expr            
        | expr OP_LT expr                
        | expr OP_LET expr               
        | expr OP_GT expr                
        | expr OP_GET expr               
        | expr OP_EQ expr                
        | expr OP_NEQ expr               
        | expr OP_MOD expr               
        | BRA_O expr BRA_C
        | BRA_O error BRA_C		{: pSynWarning("Error in expression"); :}
        | func_call                               
        | id array_index                             
        | NEW simple_type array_index                  
        | id                                         
        | CONST_BOOL                                 
        | CONST_INT                                  
        | CONST_STRING                               
        | CONST_FLOAT                               
        ;
        
id ::= ID:x 							{: RESULT = new Expr(x); :}
      | ID:x BRA_OS CONST_INT:y BRA_CS 	{: RESULT = new Expr(x, y); :}
      | ID:x BRA_OS ID:y BRA_CS 		{: RESULT = new Expr(x, y); :}
      | error BRA_CS 					{: pSynWarning("Error in vector"); :}
;   

