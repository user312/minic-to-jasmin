import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;

//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/*--------------------------------PARSER CODE ----------------------------------*/
parser code {:
	/* Symbol table for type checking */    
    HashMap<String,ArrayList<SymbolType> > symbolType_table = new HashMap<String,ArrayList<SymbolType> >();
    HashMap<String,SymbolType> symbolTypeFunction_table = new HashMap<String,SymbolType>();
    	
	// Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
    
    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    
:};

/*--------------------------------ACTION CODE ----------------------------------*/
action code {:
	
    int blockCounter = 0;
    int nErrors = 0;
    	
	ArrayList<IdType> tempParamDefList = new ArrayList<IdType>();
	ArrayList<IdType> tempParamCallList = new ArrayList<IdType>();
	
	public void addBlock()
	{
		blockCounter++;		
		//System.out.println("***BLOCCO: " + blockCounter);
	}
	
	public void remBlock()
	{
		blockCounter--;
		
		if (blockCounter <= 0)
		{
			blockCounter = 0;
			parser.symbolType_table.clear();
		}		
		
		//System.out.println("***BLOCCO: " + blockCounter);		
	}
	
	public int getBlockNumber()
	{
		return blockCounter;
	}	
		
	public int checkVar(IdType type, String id, int block)
	{
		/*
		* RETURN VALUES 
		*
		* 0: Identifier not found
		* 1: ID found -> block found
		* 2: ID found -> block not found
		*/
		
		int nRet = 0;
		ArrayList<SymbolType> symTypeList = null;
		
		symTypeList = parser.symbolType_table.get(id);
		
		if (symTypeList == null) //Identifier not found
			nRet = 0;
		else
		{
			boolean blockFound = false;							
			Iterator<SymbolType> it = symTypeList.listIterator();
		    
		    while (it.hasNext()) {
		      SymbolType s = it.next();
		      
		      if (s.getBlock() == block){
		      	blockFound = true;	//Block Found
				nRet = 1;
		      	break;
		      }		   
		    }
		    
		    if(blockFound == false) //Block not found
			{
		    	symTypeList.add(new SymbolType(type, block));	
				nRet = 2;
			}
		}	
			
		return nRet;
	}
	/*
	* Add type param to 'tempParamDefList' global list, every time a function is DECLARED	
	*/
	public void addFunctionParam(String type){
		IdType t = IdType.VOID;
								
		if(type.equals("INT"))
			t = IdType.INT; 
		else if (type.equals("FLOAT"))
			t = IdType.FLOAT;
		else if (type.equals("BOOL"))
			t = IdType.BOOL;
		else if (type.equals("STRING"))
			t = IdType.STRING; 
		
		tempParamDefList.add(t);		
	}

	/* Class used to store expression and to do type checking on expressions */
    class Expr{
        private String value;
        private SymbolType type;

		private SymbolType checkParamList(String id, ArrayList<IdType> pList)
		{
			SymbolType symType = null;
			boolean bErr = false;
			
			symType = lookupSymbolType(id);
			
			if(symType.getType() != IdType.ERR)
			{
				ArrayList<IdType> l = symType.getParamList();								
				
				/*
				System.out.println("Funzione: " + id);
				System.out.println("Lista1: " + l.size() + " - Lista2: " + pList.size());
				
				for(int j=0;j<l.size();j++)
					System.out.println("PAR " + j + ": " + l.get(j).toString());

				System.out.println("----------");

				for(int j=0;j<pList.size();j++)
					System.out.println("PAR " + j + ": " + pList.get(j).toString());
				*/
				
				if(l.size() == pList.size())
				{
					for(int i=0;i<l.size();i++)
					{
						if( !l.get(i).toString().equals(pList.get(i).toString()) ) //If params are differents
						{
							if(pList.get(i) != IdType.ERR)
			                	PrintError("Function \""+id+"\": expected " + l.get(i).toString() + ", found " + pList.get(i).toString());				                
			                
			                bErr = true;
			            }
					}
				}
				else
				{
	                PrintError("Function \""+id+"\" ERRRORE SIGNATURE"); //TODO				                
	                bErr = true;	                
				}
			}
			else
				bErr = true;
			
			tempParamCallList.clear();
			
			if (bErr == true)
				return new SymbolType(IdType.ERR);
			else
				return symType;
										
		}

        private SymbolType lookupSymbolType(String id)
        {        	        	
        	SymbolType symType = null;

			symType = parser.symbolTypeFunction_table.get(id);
            
            if (symType == null){
                PrintError("Function \""+id+"\" not declared");				                
                return new SymbolType(IdType.ERR);
            }
            return symType;
        }
        
		private SymbolType lookupSymbolType(String id, int block)
        {        	
			SymbolType sType = new SymbolType(IdType.VOID);
        	ArrayList<SymbolType> symTypeList = null;
                  
			symTypeList = parser.symbolType_table.get(id);
            
            if (symTypeList == null){
                PrintError("Variable \""+id+ " - " + block + "\" not declared");
                sType.setType(IdType.ERR);				
            }
			else{
				Iterator<SymbolType> it = symTypeList.listIterator();
				boolean blockFound = false;
				
				while (it.hasNext()) {
					SymbolType s = it.next();

					if (s.getBlock() <= block){
						blockFound = true;	//Block Found
						sType = s;
						break;
					}		   
				}
				
				if (blockFound == false){
	                PrintError("Variable \""+id+ " - " + block + "\" not declared");				                
	                return new SymbolType(IdType.ERR);					
				}
								
			}
            return sType;
        }    


        Expr(String value, SymbolType type){
            this.value = value;
            this.type = type;
        }
          
        //Called by Function      
        Expr(String id, ArrayList<IdType> pList){
            this.value = id;
            this.type = checkParamList(id, pList);
        }
        
        //Called by Function      
        Expr(String id){
            this.value = id;
            this.type = lookupSymbolType(id);
        }
        
        //Called by Variables
		Expr(String id, int block){
            this.value = id;
            this.type = lookupSymbolType(id, block);
        }

        public String toString(){
            return value;
        }
        public SymbolType getSymbolType(){
            return type;            
        }

        /* Check symbol type. In return unknown type in the case of type error */
        public SymbolType checkSymbolType(Expr expr, Operator op){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();
			IdType t = IdType.ERR;

			switch(op)
			{
				case PLUS: 
				case DIFF:
				case MUL:
				case DIV:
					
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
					{
						if (type1 == type2) 
							t = type1;
						else
							t = IdType.FLOAT; //PROM
					}
					else
						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );					
					break;
					
				case MOD:
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
						t = IdType.INT;
					else
						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );

					break;
				
				case AND:
				case OR:
					if( (type1 == type2) && (type1 == IdType.BOOL) )
						t = IdType.BOOL;
					else
						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );															
					break;

				case EQ:
				case NEQ:
					if (type1 != IdType.STRING && type2 != IdType.STRING)
						t = IdType.BOOL;
					else
						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );						
					break;

				case LT:
				case LET:
				case GT:
				case GET:
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
						t = IdType.BOOL;
					else
						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );						

					break;
			}

            return new SymbolType(t);                               
        }


        public void checkSymbolTypeAssignment(Expr expr){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();
            
            if (type1 == IdType.ERR || type2 == IdType.ERR)
            	PrintError("Error in assignment");

            // If operands are of two different types and they aren't numerics print error
            else if ( !type1.toString().equals(type2.toString()) ) 
            {                 
            	if (!(type1.IsNumeric() == true && type2.IsNumeric() == true)) //If both are numerics don't alert: PROM
                	PrintError("Can't assign " + type2.toString() + " to " + type1.toString() );                
            }
        }               
    }

 	// Error management
    private void PrintError(String message){
        System.err.println("ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        nErrors++;
        //parser.done_parsing();
    }    
:}

/*--------------------------------TERMINAL / NON TERMINAL ----------------------------------*/
// Terminal tokens
terminal TYPE_BOOL, TYPE_INT, TYPE_STRING, TYPE_VOID, TYPE_FLOAT;
terminal EXTERN;
terminal String IF, ELSE, WHILE;
terminal ASSIGN, NEW, RETURN;
terminal OP_PLUS, OP_DIFF, OP_MUL, OP_DIV, OP_MOD, OP_SIGN;
terminal OP_EQ, OP_NEQ, OP_LT, OP_LET, OP_GT, OP_GET, OP_AND, OP_OR, OP_NOT;
terminal COMMA, SEMI;
terminal BRA_O, BRA_C, BRA_OS, BRA_CS, BRA_OG, BRA_CG;

terminal String ID;
terminal Boolean CONST_BOOL;
terminal Integer CONST_INT;
terminal Float   CONST_FLOAT;
terminal String  CONST_STRING;

// Non terminal tokens
non terminal prog, stmt_list, stmt, assign_stmt;
non terminal Integer[] nt0_while;
non terminal Integer nt0_if, nt1_if;
//non terminal minug, magug;
non terminal ret_stmt, if_then_stmt, if_then_else_stmt, while_stmt;

non terminal function, func_list, func_def, func_def_ext, decl_list, decl, var_list, var, param_var, decl_param; 
non terminal param_list, formal_param;
non terminal block, br_og, br_cg, block_in, decl_param_list;
non terminal String type, simple_type, array_dim, array_index, ret_type;
non terminal Expr if_condition, while_condition;
non terminal Expr expr, id, func_call, expr_list;

/*--------------------------------PRIORITY / ASSOCIATIVITY ----------------------------------*/
//lower priority
precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQ, OP_NEQ;
precedence nonassoc OP_NOT;
precedence left OP_LT, OP_LET, OP_GT, OP_GET;
precedence left OP_PLUS, OP_DIFF;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence nonassoc OP_SIGN;
//highest priority

/*-------------------------------- GRAMMAR ----------------------------------*/
start with prog;

prog ::= func_list {: System.out.println("Compilation ended with " + nErrors + " errors."); :}
        ;

decl ::= type var_list                          
        ;

type ::= simple_type:x 				{: RESULT=x; :}                                       
     	| simple_type:x array_dim   {: RESULT=x; :}                          
     	;

simple_type ::= TYPE_BOOL		{: RESULT = new String("BOOL"); :}
        | TYPE_INT				{: RESULT = new String("INT"); :}
        | TYPE_FLOAT			{: RESULT = new String("FLOAT"); :}
        | TYPE_STRING			{: RESULT = new String("STRING"); :}
        ;

array_dim ::= BRA_OS BRA_CS
        | array_dim BRA_OS BRA_CS                       
        ;

var_list ::= var
       	| var_list COMMA {: RESULT = parser.stack(-2); :} var
       	| var_list var /* error */		{: PrintError("Missing ',' before identifier"); :}	
       	;

var ::= ID:x 		{: 
						int nRet = -1;
						IdType t = IdType.VOID;
						
						if(parser.stack(-1).equals("INT"))
		 					t = IdType.INT; 
		 				else if (parser.stack(-1).equals("FLOAT"))
		 					t = IdType.FLOAT;
		 				else if (parser.stack(-1).equals("BOOL"))
		 					t = IdType.BOOL;
		 				else if (parser.stack(-1).equals("STRING"))
		 					t = IdType.STRING;
												
						nRet = checkVar(t, x, getBlockNumber());
						
						if (nRet == 0)						
						{
							ArrayList<SymbolType> newVarList = new ArrayList<SymbolType>();
			 					
							newVarList.add(new SymbolType(t, getBlockNumber() ));			 					
							parser.symbolType_table.put(x, newVarList);
						}
		 				else if(nRet == 1) 
		 					PrintError("Variable " + x + " already declared.");
		 			:}
        ;

func_list ::= /* empty */
       	| func_list function
       	;

function ::= func_def block       
		| EXTERN func_def_ext SEMI					
		;

func_def_ext ::= CONST_STRING ret_type:x ID:y BRA_O block_in decl_param BRA_C  
						{: 							
							if(x.equals("INT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.INT, tempParamDefList)); 
   			 				else if (x.equals("FLOAT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.FLOAT, tempParamDefList));
   			 				else if (x.equals("BOOL"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.BOOL, tempParamDefList));
   			 				else if (x.equals("STRING"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.STRING, tempParamDefList));
   			 				else if (x.equals("VOID"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.VOID, tempParamDefList));
   			 					
   			 				tempParamDefList.clear();
   			 			:}                             			          		
        ;

func_def ::= ret_type:x ID:y BRA_O block_in formal_param BRA_C  	
						
						{: 							
							if(x.equals("INT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.INT, tempParamDefList)); 
   			 				else if (x.equals("FLOAT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.FLOAT, tempParamDefList));
   			 				else if (x.equals("BOOL"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.BOOL, tempParamDefList));
   			 				else if (x.equals("STRING"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.STRING, tempParamDefList));
   			 				else if (x.equals("VOID"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.VOID, tempParamDefList));
   			 					
   			 				tempParamDefList.clear();
   			 			:}

		| ret_type ID block_in formal_param /* error */ 		{: PrintError("Error in function definition "); :}		
        ;

formal_param ::= TYPE_VOID
	    | /* empty */
        | param_list                                 
        ;
            
decl_param ::= TYPE_VOID                            
	    |/* empty */											
		| decl_param_list                             
        ;

param_list ::= type:x var  								{: addFunctionParam(x); :}                                      
		| param_list COMMA type:x var  					{: addFunctionParam(x); :}                        
		| param_list type param_var /* error */ 		{: PrintError("Missing ',' before identifier"); :}            
		;
          
decl_param_list ::= type:x				{: addFunctionParam(x); :}                                  
        | decl_param_list COMMA type:x	{: addFunctionParam(x); :}                
        ;

ret_type ::= TYPE_VOID {: RESULT = new String("VOID"); :}                                 
        | type:x {: RESULT = x; :}                                       
        ;

block_in ::= /* empty */   //controllo EOF (da rivedere)                               
		;

br_og ::= BRA_OG {: addBlock(); :}
		;
br_cg ::= BRA_CG {: remBlock(); :}
		;

block ::= br_og stmt_list br_cg
		| br_og stmt_list error br_cg		{: PrintError("Missing ';' before }"); :}  
		| br_og error br_cg					{: PrintError("Missing ';' before }"); :}             
		;

stmt_list ::= /* empty */ //controllo EOF (da rivedere)                    
		| stmt_list stmt                 
        ;

stmt ::= block_in block                              
		| decl SEMI	       				
		| func_call SEMI
		| assign_stmt                             
		| ret_stmt                             
		| if_then_stmt                             
		| if_then_else_stmt                         
		| while_stmt                              
		| error SEMI						{: PrintError("Error in statement"); :}       
        ;

assign_stmt ::= id:x ASSIGN expr:y SEMI		{: x.checkSymbolTypeAssignment(y); :}            
		| id array_index ASSIGN expr SEMI  
		| id ASSIGN error SEMI				{: PrintError("Error in expression"); :}
		| error ASSIGN expr SEMI 			{: PrintError("Error in assigment"); :}
        ;

array_index ::= BRA_OS expr:x BRA_CS    {: if(x.getSymbolType().getType() != IdType.INT)
												PrintError("Error in vector. Arguments must be int.");
										:}
        | error BRA_CS 					{: PrintError("Error in vector"); 	:} 
		| array_index BRA_OS expr BRA_CS  		      
        ;

func_call ::= ID:x BRA_O /* no params */ BRA_C   	{: RESULT = new Expr(x); :}
		| ID:x BRA_O expr_list BRA_C 				{: RESULT = new Expr(x, tempParamCallList); :}            
        ;

ret_stmt ::= RETURN expr SEMI                
        ;

if_then_stmt ::= IF if_condition block_in block          
        ;

if_then_else_stmt ::= IF if_condition block_in block ELSE block_in block
		| IF if_condition block_in block error block_in block		{: PrintError("Error 'else' expected in 'if' instruction"); :}	             
        ;
        
if_condition ::= BRA_O expr:x BRA_C {: 
										if (x.getSymbolType().getType() == IdType.BOOL)
											RESULT = new Expr("if_cond", x.getSymbolType());
    									else 
										{
											PrintError("Error in 'if' condition. Required boolean, found " + x.getSymbolType().getType().toString() + ".");
											RESULT = new Expr("if_cond", new SymbolType(IdType.ERR));
										}
									:}
    	| BRA_O error BRA_C			{: PrintError("Error in 'if' condition"); :}
    	| error expr BRA_C 			{: PrintError("Error '(' expected in 'if' instruction"); :}
    	| BRA_O expr error  		{: PrintError("Error ')' expected in 'if' instruction"); :}
		;

while_stmt ::= WHILE while_condition block_in block         
        ;

while_condition ::= BRA_O expr:x BRA_C {: 
										if (x.getSymbolType().getType() == IdType.BOOL)
											RESULT = new Expr("while_cond", x.getSymbolType());
    									else 
										{
											PrintError("Error in 'while' condition. Required boolean, found " + x.getSymbolType().getType().toString() + ".");
											RESULT = new Expr("while_cond", new SymbolType(IdType.ERR));
										}
									:} 
    	| BRA_O error BRA_C			{: PrintError("Error in 'while' condition"); :}
    	| error expr BRA_C 			{: PrintError(" '(' expected in 'while' instruction"); :}
    	| BRA_O expr error  		{: PrintError(" ')' expected in 'while' instruction"); :}
		;

expr_list ::= expr:x 				{: 
										tempParamCallList.add(x.getSymbolType().getType());
									:}                             
        | expr_list COMMA expr:x    {: 
										tempParamCallList.add(x.getSymbolType().getType());
									:}    
        ;

expr ::=  expr:x OP_PLUS expr:y		   	{: RESULT = new Expr("+", x.checkSymbolType(y,Operator.PLUS)); :}              
        | expr:x OP_DIFF expr:y    	   	{: RESULT = new Expr("-", x.checkSymbolType(y,Operator.DIFF)); :}
        | expr:x OP_MUL expr:y		   	{: RESULT = new Expr("*", x.checkSymbolType(y,Operator.MUL)); :}              
        | expr:x OP_DIV expr:y		   	{: RESULT = new Expr("/", x.checkSymbolType(y,Operator.DIV)); :}               
		| OP_PLUS expr:x   				{: RESULT = new Expr("opop", x.getSymbolType()); :} %prec OP_SIGN
		| OP_DIFF expr:x   				{: RESULT = new Expr("opop", x.getSymbolType()); :} %prec OP_SIGN           
        | expr:x OP_AND expr:y		   	{: RESULT = new Expr("&&", x.checkSymbolType(y, Operator.AND)); :}               
        | expr:x OP_OR expr:y			{: RESULT = new Expr("||", x.checkSymbolType(y, Operator.OR)); :}                
        | OP_NOT expr:x                 {: 
        									if (x.getSymbolType().getType() == IdType.BOOL)      
        										RESULT = new Expr("!", x.getSymbolType());
        									else 
											{
												PrintError("Error in expression. Required boolean, found " + x.getSymbolType().getType().toString() + ".");
												RESULT = new Expr("!", new SymbolType(IdType.ERR));
											}					
        								:}         
        | BRA_O TYPE_INT BRA_C expr:x /* cast */ {: 
        											if (x.getSymbolType().getType() == IdType.FLOAT || x.getSymbolType().getType() == IdType.INT)
        												RESULT = new Expr("cast", new SymbolType(IdType.INT));
        											else 
        											{
        												PrintError("Cannot cast " + x.getSymbolType().getType().toString() + " to int.");
        												RESULT = new Expr("cast", new SymbolType(IdType.ERR));
        											} 
        										 :}         
        | expr:x OP_LT expr:y			{: RESULT = new Expr("<", x.checkSymbolType(y, Operator.LT)); :}
        | expr:x OP_LET expr:y          {: RESULT = new Expr("<=", x.checkSymbolType(y, Operator.LET)); :}     
        | expr:x OP_GT expr:y           {: RESULT = new Expr(">", x.checkSymbolType(y, Operator.GT)); :}     
        | expr:x OP_GET expr:y          {: RESULT = new Expr(">=", x.checkSymbolType(y, Operator.GET)); :}   
        | expr:x OP_EQ expr:y           {: RESULT = new Expr("==", x.checkSymbolType(y, Operator.EQ)); :}   
        | expr:x OP_NEQ expr:y          {: RESULT = new Expr("!=", x.checkSymbolType(y, Operator.NEQ)); :}    
        | expr:x OP_MOD expr:y          {: RESULT = new Expr("%", x.checkSymbolType(y, Operator.MOD)); :}    
        | BRA_O expr:x BRA_C			{: RESULT = new Expr("bras", x.getSymbolType()); :}
        | BRA_O error BRA_C				{: PrintError("Error in expression"); :}
        | func_call:x 					{: RESULT = new Expr("func_call", x.getSymbolType()); :}                               
        | id:x array_index				{: RESULT = new Expr("array_index", x.getSymbolType()); :}                             
        | NEW simple_type:x array_index {:
        									IdType t =  IdType.VOID;
        									
        									if (x.equals("INT"))
        										t=IdType.INT;
        									if (x.equals("FLOAT"))
        										t=IdType.FLOAT;
        									if (x.equals("BOOL"))
        										t=IdType.BOOL;        										
        									if (x.equals("STRING"))
        										t=IdType.STRING;
        										        										
        									RESULT = new Expr(x, new SymbolType(t));        										 
        								:}               
        | id:x 					{: RESULT = x; :}                                         
        | CONST_BOOL:x			{: RESULT = new Expr(x.toString(), new SymbolType(IdType.BOOL)); :}                                
        | CONST_INT:x			{: RESULT = new Expr(x.toString(), new SymbolType(IdType.INT)); :}                                  
        | CONST_STRING:x		{: RESULT = new Expr(x, new SymbolType(IdType.STRING)); :}                               
        | CONST_FLOAT:x 		{: RESULT = new Expr(x.toString(), new SymbolType(IdType.FLOAT)); :}                               
        ;
        
id ::= ID:x		{: RESULT = new Expr(x, getBlockNumber()); :}
		;   
