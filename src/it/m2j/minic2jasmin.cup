import java_cup.runtime.*;
import java.util.HashMap;

//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/*--------------------------------PARSER CODE ----------------------------------*/
parser code {:
	/* Symbol table for type checking */
    HashMap<String,SymbolType> symbolType_table = new HashMap<String,SymbolType>();
    HashMap<String,SymbolType> symbolTypeFunction_table = new HashMap<String,SymbolType>();

	// Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
    
    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    
:};

/*--------------------------------ACTION CODE ----------------------------------*/
action code {:

	/* Class used to store expression and to do type checking on expressions */
    class Expr{
        private String value;
        private SymbolType type;

        private SymbolType lookupSymbolType(String id, LookUp l)
        {        	
        	String s = "";
        	SymbolType symType = null;
        
            if (l == LookUp.VAR)
            {
            	symType = parser.symbolType_table.get(id);
            	s = "Variable";
            }
            else if(l == LookUp.FUNC)
            {
            	symType = parser.symbolTypeFunction_table.get(id);
            	s = "Function";
            }
            
            if (symType == null){
                pSemError(s + " \""+id+"\" not declared");				                
                return new SymbolType(IdType.VOID);
            }
            return symType;
        }
        
        Expr(String value, SymbolType type){
            this.value = value;
            this.type = type;
        }
        
        Expr(String id, LookUp l){
            this.value = id;
            this.type = lookupSymbolType(id, l);
        }

        Expr(String id, Integer pos){
            this.value = id+"["+pos.toString()+"]";
            this.type = lookupSymbolType(id, LookUp.VAR);

            int dim = type.getDim();
            if (pos>=dim && dim!=-1){
                pSemError("Array index ("+pos+") exceed array size ("+dim+")");
            }
        }
        Expr(String id, String pos){
            this.value = id+"["+pos+"]";
            this.type = lookupSymbolType(id, LookUp.VAR);
        }

        public String toString(){
            return value;
        }
        public SymbolType getSymbolType(){
            return type;            
        }

        /* Check symbol type. In return unknown type in the case of type error */
        public SymbolType checkSymbolType(Expr expr, Operator op){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();
			IdType t = IdType.VOID;

			switch(op)
			{
				case PLUS: 
				case DIFF:
				case MUL:
				case DIV:
					
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
					{
						if (type1 == type2) 
							t = type1;
						else
							t = IdType.FLOAT;
					}
					else
						pSemWarning("Incomparable types: " + type1.toString() + " to " + type2.toString() );					
					break;
					
				case MOD:
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
						t = IdType.INT;
					else
						pSemWarning("Incomparable types: " + type1.toString() + " to " + type2.toString() );

					break;
				
				case AND:
				case OR:
					if( (type1 == type2) && (type1 == IdType.BOOL) )
						t = IdType.BOOL;
					else
						pSemWarning("Incomparable types: " + type1.toString() + " to " + type2.toString() );															
					break;

				case EQ:
				case NEQ:
					if (type1 != IdType.STRING && type2 != IdType.STRING)
						t = IdType.BOOL;
					else
						pSemWarning("Incomparable types: " + type1.toString() + " to " + type2.toString() );						
					break;

				case LT:
				case LET:
				case GT:
				case GET:
					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
						t = IdType.BOOL;
					else
						pSemWarning("Incomparable types: " + type1.toString() + " to " + type2.toString() );						

					break;
			}

            return new SymbolType(t);                               
        }


        public void checkSymbolTypeAssignment(Expr expr){
            IdType type1 = type.getType();
            IdType type2 = expr.getSymbolType().getType();

            if (!type1.toString().equals(type2.toString())){
                // If operands are of two different types print error 
                pSemWarning("Can't assign " + type2.toString() + " to " + type1.toString() );                
            }
        }               
    }

 	// Error management
    private void pSemError(String message){
        System.err.println("SEM ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        //parser.done_parsing();
    }
    private void pSemWarning(String message){
        System.err.println("SEM WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
    }
    private void pSynError(String message){
        System.err.println("SYN ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        //parser.done_parsing();
    }
    private void pSynWarning(String message){
        System.err.println("SYN WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        /* Quando c'è un errore sintattico continuo il parsing ma disabilito la semantica */
        //disableSem();
    }    
:}

/*--------------------------------TERMINAL / NON TERMINAL ----------------------------------*/
// Terminal tokens
terminal TYPE_BOOL, TYPE_INT, TYPE_STRING, TYPE_VOID, TYPE_FLOAT;
terminal EXTERN;
terminal String IF, ELSE, WHILE;
terminal ASSIGN, NEW, RETURN;
terminal OP_PLUS, OP_DIFF, OP_MUL, OP_DIV, OP_MOD, OP_SIGN;
terminal OP_EQ, OP_NEQ, OP_LT, OP_LET, OP_GT, OP_GET, OP_AND, OP_OR, OP_NOT;
terminal COMMA, SEMI;
terminal BRA_O, BRA_C, BRA_OS, BRA_CS, BRA_OG, BRA_CG;

terminal String ID;
terminal Boolean CONST_BOOL;
terminal Integer CONST_INT;
terminal Float   CONST_FLOAT;
terminal String  CONST_STRING;

// Non terminal tokens
non terminal prog, stmt_list, stmt, assign_stmt;
non terminal Integer[] nt0_while;
non terminal Integer nt0_if, nt1_if;
//non terminal minug, magug;
non terminal ret_stmt, if_then_stmt, if_then_else_stmt, while_stmt;

non terminal function, func_list, func_def, func_def_ext, decl_list, decl, var_list, var, decl_param, formal_param;
non terminal block, block_in, param_list, decl_param_list;
non terminal String type, simple_type, array_dim, array_index, ret_type;
non terminal String if_condition, while_condition;
non terminal Expr expr, id, func_call, expr_list;

/*--------------------------------PRIORITY / ASSOCIATIVITY ----------------------------------*/
//lower priority
precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQ, OP_NEQ;
precedence nonassoc OP_NOT;
precedence left OP_LT, OP_LET, OP_GT, OP_GET;
precedence left OP_PLUS, OP_DIFF;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence nonassoc OP_SIGN;
//highest priority

/*-------------------------------- GRAMMAR ----------------------------------*/
start with prog;

prog ::= func_list
        ;

decl ::= type var_list                          
        ;

type ::= simple_type:x 				{: RESULT=x; :}                                       
     	| simple_type:x array_dim   {: RESULT=x; :}                          
     	;

simple_type ::= TYPE_BOOL		{: RESULT = new String("BOOL"); :}
        | TYPE_INT				{: RESULT = new String("INT"); :}
        | TYPE_FLOAT			{: RESULT = new String("FLOAT"); :}
        | TYPE_STRING			{: RESULT = new String("STRING"); :}
        ;

array_dim ::= BRA_OS BRA_CS
        | array_dim BRA_OS BRA_CS                       
        ;

var_list ::= var
       	| var_list COMMA {: RESULT = parser.stack(-2); :} var
       	| var_list var /* error */		{: pSynWarning("Missing ',' before identifier"); :}	
       	;

var ::= ID:x 		{: if(parser.stack(-1).equals("INT"))
		 					parser.symbolType_table.put(x, new SymbolType(IdType.INT)); 
		 				else if (parser.stack(-1).equals("FLOAT"))
		 					parser.symbolType_table.put(x, new SymbolType(IdType.FLOAT));
		 				else if (parser.stack(-1).equals("BOOL"))
		 					parser.symbolType_table.put(x, new SymbolType(IdType.BOOL));
		 				else if (parser.stack(-1).equals("STRING"))
		 					parser.symbolType_table.put(x, new SymbolType(IdType.STRING));
		 			:}
        ;

func_list ::= /* empty */
       	| func_list function
       	;

function ::= func_def block       
		| EXTERN func_def_ext SEMI					
		;

func_def_ext ::= CONST_STRING ret_type ID BRA_O block_in decl_param BRA_C                               			          		
        ;

func_def ::= ret_type:x ID:y BRA_O block_in formal_param BRA_C  	
						
						{: if(x.equals("INT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.INT)); 
   			 				else if (x.equals("FLOAT"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.FLOAT));
   			 				else if (x.equals("BOOL"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.BOOL));
   			 				else if (x.equals("STRING"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.STRING));
   			 				else if (x.equals("VOID"))
   			 					parser.symbolTypeFunction_table.put(y, new SymbolType(IdType.VOID));
   			 			:}

		| ret_type ID block_in formal_param /* error */ 		{: pSynWarning("Error in function definition "); :}		
        ;

formal_param ::= TYPE_VOID
	    | /* empty */
        | param_list                                 
        ;
            
decl_param ::= TYPE_VOID                            
	    |/* empty */											
		| decl_param_list                             
        ;

param_list ::= type var                                     
		| param_list COMMA type var                     
		| param_list type var /* error */ 		{: pSynWarning("Missing ',' before identifier"); :}            
    	;
          
decl_param_list ::= type                                    
        | decl_param_list COMMA type                    
        ;

ret_type ::= TYPE_VOID {: RESULT = new String("VOID"); :}                                 
        | type:x {: RESULT = x; :}                                       
        ;

block_in ::= /* empty */   //controllo EOF (da rivedere)                               
		;

block ::= BRA_OG stmt_list BRA_CG
		| BRA_OG stmt_list error BRA_CG			{: pSynWarning("Missing ';' before }"); :}  
		| BRA_OG error BRA_CG					{: pSynWarning("Missing ';' before }"); :}             
		;

stmt_list ::= /* empty */ //controllo EOF (da rivedere)                    
		| stmt_list stmt                 
        ;

stmt ::= block_in block                              
		| decl SEMI	       				
		| func_call SEMI
		| assign_stmt                             
		| ret_stmt                             
		| if_then_stmt                             
		| if_then_else_stmt                         
		| while_stmt                              
		| error SEMI			{: pSynWarning("Error in statement"); :}       
        ;

assign_stmt ::= id:x ASSIGN expr:y SEMI		{: x.checkSymbolTypeAssignment(y); :}            
		| id array_index ASSIGN expr SEMI  
		| id ASSIGN error SEMI				{: pSynWarning("Error in expression"); :}
		| error ASSIGN expr SEMI 			{: pSynWarning("Error in assigment"); :}
        ;

array_index ::= BRA_OS expr BRA_CS 
        | error BRA_CS 					{: pSynWarning("Error in vector"); 	:} 
		| array_index BRA_OS expr BRA_CS  		      
        ;

func_call ::= ID:x BRA_O /* no params */ BRA_C   	{: RESULT = new Expr(x, LookUp.FUNC); :}      
		| ID:x BRA_O expr_list BRA_C 				{: RESULT = new Expr(x, LookUp.FUNC); :}            
        ;

ret_stmt ::= RETURN expr SEMI                
        ;

if_then_stmt ::= IF if_condition block_in block          
        ;

if_then_else_stmt ::= IF if_condition block_in block ELSE block_in block
		| IF if_condition block_in block error block_in block		{: pSynWarning("Error 'else' expected in 'if' instruction"); :}	             
        ;
        
if_condition ::= BRA_O expr BRA_C 
    	| BRA_O error BRA_C			{: pSynWarning("Error in 'if' condition"); :}
    	| error expr BRA_C 			{: pSynWarning("Error '(' expected in 'if' instruction"); :}
    	| BRA_O expr error  		{: pSynWarning("Error ')' expected in 'if' instruction"); :}
		;

while_stmt ::= WHILE while_condition block_in block         
        ;

while_condition ::= BRA_O expr BRA_C 
    	| BRA_O error BRA_C			{: pSynWarning("Error in 'while' condition"); :}
    	| error expr BRA_C 			{: pSynWarning("Error '(' expected in 'while' instruction"); :}
    	| BRA_O expr error  		{: pSynWarning("Error ')' expected in 'while' instruction"); :}
		;

expr_list ::= expr:x {: RESULT = new Expr("exp", x.getSymbolType()); :}                             
        | expr_list COMMA expr        
        ;

expr ::=  expr:x OP_PLUS expr:y		   	{: RESULT = new Expr("+", x.checkSymbolType(y,Operator.PLUS)); :}              
        | expr:x OP_DIFF expr:y    	   	{: RESULT = new Expr("-", x.checkSymbolType(y,Operator.DIFF)); :}
        | expr:x OP_MUL expr:y		   	{: RESULT = new Expr("*", x.checkSymbolType(y,Operator.MUL)); :}              
        | expr:x OP_DIV expr:y		   	{: RESULT = new Expr("/", x.checkSymbolType(y,Operator.DIV)); :}               
		| OP_DIFF expr:x /* %prec OP_SIGN*/ 	{: RESULT = new Expr("opop", x.getSymbolType()); :}           
        | expr:x OP_AND expr:y		   	{: RESULT = new Expr("&&", x.checkSymbolType(y, Operator.AND)); :}               
        | expr:x OP_OR expr:y			{: RESULT = new Expr("||", x.checkSymbolType(y, Operator.OR)); :}                
        | OP_NOT expr:x                 {: RESULT = new Expr("bla", x.getSymbolType()); :}         
        | BRA_O TYPE_INT BRA_C expr:x /* cast */ {: RESULT = new Expr("bla", x.getSymbolType()); :}         
        | expr:x OP_LT expr:y			{: RESULT = new Expr("<", x.checkSymbolType(y, Operator.LT)); :}
        | expr:x OP_LET expr:y          {: RESULT = new Expr("<=", x.checkSymbolType(y, Operator.LET)); :}     
        | expr:x OP_GT expr:y           {: RESULT = new Expr(">", x.checkSymbolType(y, Operator.GT)); :}     
        | expr:x OP_GET expr:y          {: RESULT = new Expr(">=", x.checkSymbolType(y, Operator.GET)); :}   
        | expr:x OP_EQ expr:y           {: RESULT = new Expr("==", x.checkSymbolType(y, Operator.EQ)); :}   
        | expr:x OP_NEQ expr:y          {: RESULT = new Expr("!=", x.checkSymbolType(y, Operator.NEQ)); :}    
        | expr:x OP_MOD expr:y          {: RESULT = new Expr("%", x.checkSymbolType(y, Operator.MOD)); :}    
        | BRA_O expr:x BRA_C			{: RESULT = new Expr("bla", x.getSymbolType()); :}
        | BRA_O error BRA_C				{: pSynWarning("Error in expression"); :}
        | func_call:x 					{: RESULT = new Expr("bla", x.getSymbolType()); :}                               
        | id:x array_index				{: RESULT = new Expr("bla", x.getSymbolType()); :}                             
        | NEW simple_type:x array_index {:
        									IdType t =  IdType.VOID;
        									
        									if (x.equals("INT"))
        										t=IdType.INT;
        									if (x.equals("FLOAT"))
        										t=IdType.FLOAT;
        									if (x.equals("BOOL"))
        										t=IdType.BOOL;        										
        									if (x.equals("STRING"))
        										t=IdType.STRING;
        										        										
        									RESULT = new Expr(x, new SymbolType(t));        										 
        								:}               
        | id:x 					{: RESULT = x; :}                                         
        | CONST_BOOL:x			{: RESULT = new Expr(x.toString(), new SymbolType(IdType.BOOL)); :}                                
        | CONST_INT:x			{: RESULT = new Expr(x.toString(), new SymbolType(IdType.INT)); :}                                  
        | CONST_STRING:x		{: RESULT = new Expr(x, new SymbolType(IdType.STRING)); :}                               
        | CONST_FLOAT:x 		{: RESULT = new Expr(x.toString(), new SymbolType(IdType.FLOAT)); :}                               
        ;
        
id ::= ID:x		{: RESULT = new Expr(x, LookUp.VAR); :}
		;   
