import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import ast.*;

//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/*--------------------------------PARSER CODE ----------------------------------*/
parser code {:
	/* Symbol table for type checking */    
    HashMap<String,ArrayList<SymbolDesc> > SymbolDesc_table = new HashMap<String,ArrayList<SymbolDesc> >();
    HashMap<String,SymbolDesc> SymbolDescFunction_table = new HashMap<String,SymbolDesc>();
    	
	// Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
    
    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    
:};

/*--------------------------------ACTION CODE ----------------------------------*/
action code {:
	
    int blockCounter = 0;
    int nErrors = 0;
    	
	public void addBlock()
	{
		blockCounter++;		
		//System.out.println("***BLOCCO: " + blockCounter);
	}
	
	public void remBlock()
	{
		blockCounter--;
		
		if (blockCounter <= 0)
		{
			blockCounter = 0;
			parser.SymbolDesc_table.clear();
		}		
		
		//System.out.println("***BLOCCO: " + blockCounter);		
	}
	
	public int getBlockNumber()
	{
		return blockCounter;
	}	
		
//	public int checkVar(IdType type, String id, int block)
//	{
//		/*
//		* RETURN VALUES 
//		*
//		* 0: Identifier not found
//		* 1: ID found -> block found
//		* 2: ID found -> block not found
//		*/
//		
//		int nRet = 0;
//		ArrayList<SymbolDesc> symTypeList = null;
//		
//		symTypeList = parser.SymbolDesc_table.get(id);
//		
//		if (symTypeList == null) //Identifier not found
//			nRet = 0;
//		else
//		{
//			boolean blockFound = false;							
//			Iterator<SymbolDesc> it = symTypeList.listIterator();
//		    
//		    while (it.hasNext()) {
//		      SymbolDesc s = it.next();
//		      
//		      if (s.getBlock() == block){
//		      	blockFound = true;	//Block Found
//				nRet = 1;
//		      	break;
//		      }		   
//		    }
//		    
//		    if(blockFound == false) //Block not found
//			{
//		    	symTypeList.add(new SymbolDesc(type, block));	
//				nRet = 2;
//			}
//		}	
//			
//		return nRet;
//	}
//	/*
//	* Add type param to 'tempParamDefList' global list, every time a function is DECLARED	
//	*/
//	public void addFunctionParam(String type){
//		IdType t = IdType.VOID;
//								
//		if(type.equals("INT"))
//			t = IdType.INT; 
//		else if (type.equals("FLOAT"))
//			t = IdType.FLOAT;
//		else if (type.equals("BOOL"))
//			t = IdType.BOOL;
//		else if (type.equals("STRING"))
//			t = IdType.STRING; 
//		
//		tempParamDefList.add(t);		
//	}
//
//	/* Class used to store expression and to do type checking on expressions */
//    class Expr{
//        private String value;
//        private SymbolDesc type;
//
//		private SymbolDesc checkParamList(String id, ArrayList<IdType> pList)
//		{
//			SymbolDesc symType = null;
//			boolean bErr = false;
//			
//			symType = lookupSymbolDesc(id);
//			
//			if(symType.getType() != IdType.ERR)
//			{
//				ArrayList<IdType> l = symType.getParamList();								
//				
//				/*
//				System.out.println("Funzione: " + id);
//				System.out.println("Lista1: " + l.size() + " - Lista2: " + pList.size());
//				
//				for(int j=0;j<l.size();j++)
//					System.out.println("PAR " + j + ": " + l.get(j).toString());
//
//				System.out.println("----------");
//
//				for(int j=0;j<pList.size();j++)
//					System.out.println("PAR " + j + ": " + pList.get(j).toString());
//				*/
//				
//				if(l.size() == pList.size())
//				{
//					for(int i=0;i<l.size();i++)
//					{
//						if( !l.get(i).toString().equals(pList.get(i).toString()) ) //If params are differents
//						{
//							if(pList.get(i) != IdType.ERR)
//			                	PrintError("Function \""+id+"\": expected " + l.get(i).toString() + ", found " + pList.get(i).toString());				                
//			                
//			                bErr = true;
//			            }
//					}
//				}
//				else
//				{
//					if(pList.size() > 0)
//					{
//						String args=pList.get(0).toString();
//						
//						for(int i=1;i<pList.size();i++)
//							args= args + ", " + pList.get(i).toString();
//		                	
//		                PrintError("Function \""+id+"\" is not applicable for the arguments: (" + args + ").");			                
//					}
//					else
//						PrintError("Function \""+id+"\" is not applicable without arguments.");
//	                
//	                bErr = true;	                
//				}
//			}
//			else
//				bErr = true;
//			
//			tempParamCallList.clear();
//			
//			if (bErr == true)
//				return new SymbolDesc(IdType.ERR);
//			else
//				return symType;
//										
//		}
//
//        private SymbolDesc lookupSymbolDesc(String id)
//        {        	        	
//        	SymbolDesc symType = null;
//
//			symType = parser.SymbolDescFunction_table.get(id);
//            
//            if (symType == null){
//                PrintError("Function \""+id+"\" not declared");				                
//                return new SymbolDesc(IdType.ERR);
//            }
//            return symType;
//        }
//        
//		private SymbolDesc lookupSymbolDesc(String id, int block)
//        {        	
//			SymbolDesc sType = new SymbolDesc(IdType.VOID);
//        	ArrayList<SymbolDesc> symTypeList = null;
//                  
//			symTypeList = parser.SymbolDesc_table.get(id);
//            
//            if (symTypeList == null){
//                PrintError("Variable \""+id+ "\" not declared");
//                sType.setType(IdType.ERR);				
//            }
//			else{
//				Iterator<SymbolDesc> it = symTypeList.listIterator();
//				boolean blockFound = false;
//				
//				while (it.hasNext()) {
//					SymbolDesc s = it.next();
//
//					if (s.getBlock() <= block){
//						blockFound = true;	//Block Found
//						sType = s;
//						break;
//					}		   
//				}
//				
//				if (blockFound == false){
//	                PrintError("Variable \""+id+ " - " + block + "\" not declared");				                
//	                return new SymbolDesc(IdType.ERR);					
//				}
//								
//			}
//            return sType;
//        }    
//
//
//        Expr(String value, SymbolDesc type){
//            this.value = value;
//            this.type = type;
//        }
//          
//        //Called by Function      
//        Expr(String id, ArrayList<IdType> pList){
//            this.value = id;
//            this.type = checkParamList(id, pList);
//        }
//        
//        //Called by Function      
//        Expr(String id){
//            this.value = id;
//            this.type = lookupSymbolDesc(id);
//        }
//        
//        //Called by Variables
//		Expr(String id, int block){
//            this.value = id;
//            this.type = lookupSymbolDesc(id, block);
//        }
//
//        public String toString(){
//            return value;
//        }
//        public SymbolDesc getSymbolDesc(){
//            return type;            
//        }
//
//        /* Check symbol type. In return unknown type in the case of type error */
//        public SymbolDesc checkSymbolDesc(Expr expr, Operator op){
//            IdType type1 = type.getType();
//            IdType type2 = expr.getSymbolDesc().getType();
//			IdType t = IdType.ERR;
//
//			switch(op)
//			{
//				case PLUS: 
//				case DIFF:
//				case MUL:
//				case DIV:
//					
//					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
//					{
//						if (type1 == type2) 
//							t = type1;
//						else
//							t = IdType.FLOAT; //PROM
//					}
//					else
//						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );					
//					break;
//					
//				case MOD:
//					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
//						t = IdType.INT;
//					else
//						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );
//
//					break;
//				
//				case AND:
//				case OR:
//					if( (type1 == type2) && (type1 == IdType.BOOL) )
//						t = IdType.BOOL;
//					else
//						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );															
//					break;
//
//				case EQ:
//				case NEQ:
//					if (type1 != IdType.STRING && type2 != IdType.STRING)
//						t = IdType.BOOL;
//					else
//						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );						
//					break;
//
//				case LT:
//				case LET:
//				case GT:
//				case GET:
//					if(type1.IsNumeric() == true && type2.IsNumeric() == true)
//						t = IdType.BOOL;
//					else
//						PrintError("Incomparable types: " + type1.toString() + " to " + type2.toString() );						
//
//					break;
//			}
//
//            return new SymbolDesc(t);                               
//        }
//
//
//        public void checkSymbolDescAssignment(Expr expr){
//            IdType type1 = type.getType();
//            IdType type2 = expr.getSymbolDesc().getType();
//            
//            if (type1 == IdType.ERR || type2 == IdType.ERR)
//            	PrintError("Error in assignment");
//
//            // If operands are of two different types and they aren't numerics print error
//            else if ( !type1.toString().equals(type2.toString()) ) 
//            {                 
//            	if (!(type1.IsNumeric() == true && type2.IsNumeric() == true)) //If both are numerics don't alert: PROM
//                	PrintError("Can't assign " + type2.toString() + " to " + type1.toString() );
//                else if(type1 == IdType.INT && type2 == IdType.FLOAT)
//					PrintError("Can't assign " + type2.toString() + " to " + type1.toString() + ". Required cast." );                	                
//            }
//        }               
//    }
//

 	// Error management
    private void PrintError(String message){
        System.err.println("ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        nErrors++;
        //parser.done_parsing();
    }    
:}

/*--------------------------------TERMINAL / NON TERMINAL ----------------------------------*/
// Terminal tokens
terminal TYPE_BOOL, TYPE_INT, TYPE_STRING, TYPE_VOID, TYPE_FLOAT;
terminal EXTERN;
terminal String IF, ELSE, WHILE;
terminal ASSIGN, NEW, RETURN;
terminal OP_PLUS, OP_DIFF, OP_MUL, OP_DIV, OP_MOD, OP_SIGN;
terminal OP_EQ, OP_NEQ, OP_LT, OP_LET, OP_GT, OP_GET, OP_AND, OP_OR, OP_NOT;
terminal COMMA, SEMI;
terminal BRA_O, BRA_C, BRA_OS, BRA_CS, BRA_OG, BRA_CG;

terminal String ID;
terminal Boolean CONST_BOOL;
terminal Integer CONST_INT;
terminal Float   CONST_FLOAT;
terminal String  CONST_STRING;

// Non terminal tokens
non terminal ListNode prog, func_list, param_list, stmt_list, expr_list, decl_param, decl_param_list;
non terminal DeclNode decl; 
non terminal Node function, stmt;
non terminal FuncCallNode func_call;
non terminal BlockNode block;
non terminal ReturnNode ret_stmt;
non terminal AssignNode assign_stmt;
non terminal WhileNode while_stmt;
non terminal IfNode if_then_stmt;
non terminal IfElseNode if_then_else_stmt;
non terminal IdType simple_type, type, ret_type;
non terminal ExprNode expr, if_condition, while_condition, array_index;

non terminal array_dim;

/*--------------------------------PRIORITY / ASSOCIATIVITY ----------------------------------*/
//lower priority
precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQ, OP_NEQ;
precedence nonassoc OP_NOT;
precedence left OP_LT, OP_LET, OP_GT, OP_GET;
precedence left OP_PLUS, OP_DIFF;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence nonassoc OP_SIGN;
//highest priority

/*-------------------------------- GRAMMAR ----------------------------------*/
start with prog;

prog ::= func_list:x				{: RESULT = x; :}		
        ;

decl ::= type:t ID:x      			{: RESULT = new DeclNode(x, t, -99, xleft, xright); :}                    
        ;

type ::= simple_type:x 				{: RESULT=x; :}                                       
     	| simple_type:x array_dim   {: RESULT=x; :}                          
     	;

simple_type ::= TYPE_BOOL			{: RESULT = IdType.BOOL; :}
        | TYPE_INT					{: RESULT = IdType.INT; :}
        | TYPE_FLOAT				{: RESULT = IdType.FLOAT; :}
        | TYPE_STRING				{: RESULT = IdType.STRING; :}
        ;

array_dim ::= BRA_OS BRA_CS
        | array_dim BRA_OS BRA_CS                       
        ;      	

func_list ::= 
		| func_list:x function:y	{: RESULT = new ListNode(x, y); :}
       	;

function ::= ret_type:x ID:y BRA_O param_list:params BRA_C block:b     						{: RESULT = new FunctionNode(y, params, x, b, yleft, yright); :}  
		| EXTERN CONST_STRING ret_type:x ID:y BRA_O decl_param:params BRA_C SEMI			{: RESULT = new FunctionExtNode(y, x, params, yleft, yright); :}
		| ret_type ID param_list /* error */ 												{: PrintError("Error in function definition "); :}				
		;

decl_param ::=                             
	    |/* empty */											
		| decl_param_list:x {: RESULT = x; :}  
		;
		
decl_param_list ::= type:t				{: RESULT = new ListNode(new ArgNode(t, tleft, tright), null); :}                                  
        | decl_param_list:l COMMA type:t	{: RESULT = new ListNode(l,new ArgNode(t, tleft, tright)); :}
        ;
                		
param_list ::= /* empty */						{: RESULT = null; :} 
		| type:t ID:x  							{: RESULT = new ListNode(new ArgNode(x, t, xleft, xright), null); :}                                    
		| param_list:l COMMA type:t ID:x  		{: RESULT = new ListNode(l,new ArgNode(x, t, xleft, xright)); :}                      
		| param_list type ID /* error */ 		{: PrintError("Missing ',' before identifier"); :}            
		;

ret_type ::= TYPE_VOID 		{: RESULT = IdType.VOID; :}                                 
        | type:x 			{: RESULT = x; :}                                       
        ;
                
/* conteggio blocchi per scope
br_og ::= BRA_OG {: addBlock(); :}
		;
br_cg ::= BRA_CG {: remBlock(); :}
		;
*/

block ::= BRA_OG:lb stmt_list:x BRA_CG			{: RESULT = new BlockNode(x, lbleft, lbright); :}
		| BRA_OG stmt_list error BRA_CG			{: PrintError("Missing ';' before }"); :}  
		| BRA_OG error BRA_CG					{: PrintError("Missing ';' before }"); :}             
		;

stmt_list ::= 					{: RESULT = null; :}                    
		| stmt_list:x stmt:y    {: RESULT = new ListNode(x, y); :}
        ;

stmt ::= block:b					{: RESULT = b; :}                              
		| decl:d SEMI				{: RESULT = d; :}	       				
		| func_call:fc SEMI			{: RESULT = fc; :}
		| assign_stmt:a         	{: RESULT = a; :}                 
		| ret_stmt:x            	{: RESULT = x; :}               
		| if_then_stmt:x        	{: RESULT = x; :}                 
		| if_then_else_stmt:x    	{: RESULT = x; :}                   
		| while_stmt:x              {: RESULT = x; :}            
		| error SEMI				{: PrintError("Error in statement"); :}       
        ;

assign_stmt ::= ID:x ASSIGN expr:y SEMI				{: RESULT = new AssignNode(x, y, xleft, xright); :}            
		| ID:x array_index ASSIGN expr:y SEMI  		{: RESULT = new AssignNode(x, y, xleft, xright); :}
		| ID ASSIGN error SEMI						{: PrintError("Error in expression"); :}
		| error ASSIGN expr SEMI 					{: PrintError("Error in assigment"); :}
        ;

array_index ::= BRA_OS expr:x BRA_CS    			{: RESULT = x; :}
        | error BRA_CS 								{: PrintError("Error in vector"); :} 
		| array_index BRA_OS expr:x BRA_CS  		{: RESULT = x; :}
        ;

func_call ::= ID:x BRA_O /* no params */ BRA_C   	{: RESULT = new FuncCallNode(x, xleft, xright); :}
		| ID:x BRA_O expr_list:y BRA_C 				{: RESULT = new FuncCallNode(x, y, xleft, xright); :}
        ;

ret_stmt ::= RETURN:r expr:e SEMI       			{: RESULT = new ReturnNode(e, rleft, rright); :}         
        ;

if_then_stmt ::= IF:n if_condition:c block:b     	{: RESULT = new IfNode(c, b, nleft, nright); :}     
        ;

if_then_else_stmt ::= IF:n if_condition:c block:b1 ELSE block:b2		{: RESULT = new IfElseNode(c, b1, b2, nleft, nright); :}
		| IF if_condition block error block								{: PrintError("Error 'else' expected in 'if' instruction"); :}	             
        ;
        
if_condition ::= BRA_O expr:x BRA_C {: RESULT = x; :}
    	| BRA_O error BRA_C			{: PrintError("Error in 'if' condition"); :}
    	| error expr BRA_C 			{: PrintError("Error '(' expected in 'if' instruction"); :}
    	| BRA_O expr error  		{: PrintError("Error ')' expected in 'if' instruction"); :}
		;

while_stmt ::= WHILE:n while_condition:c block:b	{: RESULT = new WhileNode(c, b, nleft, nright); :}        
        ;

while_condition ::= BRA_O expr:x BRA_C 		{: RESULT = x; :} 
    	| BRA_O error BRA_C					{: PrintError("Error in 'while' condition"); :}
    	| error expr BRA_C 					{: PrintError(" '(' expected in 'while' instruction"); :}
    	| BRA_O expr error  				{: PrintError(" ')' expected in 'while' instruction"); :}
		;

expr_list ::= expr:x 					{: RESULT = new ListNode(x,null); :}                             
        | expr_list:l COMMA expr:x    	{: RESULT = new ListNode(l,x); :}    // for argument in function call
        ;

expr ::=  expr:x OP_PLUS:n expr:y		{: RESULT = new AddNode(x, y, nleft, nright); :}             
        | expr:x OP_DIFF:n expr:y    	{: RESULT = new SubNode(x, y, nleft, nright); :}
        | expr:x OP_MUL:n expr:y		{: RESULT = new MulNode(x, y, nleft, nright); :}              
        | expr:x OP_DIV:n expr:y		{: RESULT = new DivNode(x, y, nleft, nright); :}              
		| OP_PLUS:n expr:x   			{: RESULT = new SignNode(x, nleft, nright); :} %prec OP_SIGN
		| OP_DIFF:n expr:x   			{: RESULT = new SignNode(x, nleft, nright); :} %prec OP_SIGN      
        | expr:x OP_AND:n expr:y		{: RESULT = new AndNode(x, y, nleft, nright); :}              
        | expr:x OP_OR:n expr:y			{: RESULT = new OrNode(x, y, nleft, nright); :}               
        | OP_NOT:n expr:x               {: RESULT = new NotNode(x, nleft, nright); :}				        
        | BRA_O TYPE_INT:n BRA_C expr:x /* cast */ {: RESULT = new CastNode(x, nleft, nright); :}
        									        
        | expr:x OP_LT:n expr:y			{: RESULT = new LTNode(x, y, nleft, nright); :}
        | expr:x OP_LET:n expr:y        {: RESULT = new LETNode(x, y, nleft, nright); :}    
        | expr:x OP_GT:n expr:y         {: RESULT = new GTNode(x, y, nleft, nright); :}
        | expr:x OP_GET:n expr:y        {: RESULT = new GETNode(x, y, nleft, nright); :}   
        | expr:x OP_EQ:n expr:y         {: RESULT = new EqNode(x, y, nleft, nright); :}   
        | expr:x OP_NEQ:n expr:y        {: RESULT = new NotEqNode(x, y, nleft, nright); :}    
        | expr:x OP_MOD:n expr:y        {: RESULT = new ModNode(x, y, nleft, nright); :}    
        | BRA_O expr:x BRA_C			{: RESULT = new BracketNode(x, xleft, xright); :}
        | BRA_O error BRA_C				{: PrintError("Error in expression"); :}   //errore da gestire
        | func_call:x 					{: RESULT = x; :}                  
        | ID:x array_index				//{: RESULT = ArrayElementNode(x, parser.stack(-2), xleft, xright); :}    // APPOI VIREMU                        
        | NEW simple_type:x array_index //{: RESULT = new ArrayNode(x, y, nleft, nright); :}						//APPOI VIREMU
        									             
        | ID:x 					{: RESULT = null; :}                                         
        | CONST_BOOL:x			{: RESULT = new BoolNode(x, xleft, xright); :}                                
        | CONST_INT:x			{: RESULT = new IntNode(x, xleft, xright); :}                                  
        | CONST_STRING:x		{: RESULT = new StringNode(x, xleft, xright); :}                               
        | CONST_FLOAT:x 		{: RESULT = new FloatNode(x, xleft, xright); :}                               
        ;