import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import ast.*;

//init with {: scanner.init();              :};
//scan with {: return scanner.next_token(); :};

/*--------------------------------PARSER CODE ----------------------------------*/
parser code {:
    	
	// Redefinition of error functions
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }
    
    public void syntax_error(Symbol cur_token){}
    
    // Return actual symbol
    public Symbol getToken() {
        return ((Symbol)stack.elementAt(tos));
    }

    // Return semantic value of symbol in position (position)
    public Object stack(int position) {
        return (((Symbol)stack.elementAt(tos+position)).value);
    }

    // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }
    
    
:};

/*--------------------------------ACTION CODE ----------------------------------*/
action code {:
	
    int blockCounter = 0; //The official
    
    int tempBlockCounter = 0; //keeps track of the max block number. Never decreases.
    int tempBlockRem = 0; //+1 on "{" and -1 on "}". Always.
    
    int nErrors = 0;
    	
	public void addBlock()
	{	
		tempBlockRem++;
		tempBlockCounter++;
		blockCounter=tempBlockCounter;
	}
	
	public void remBlock()
	{
		tempBlockRem--;			
		blockCounter--;
		
		if (tempBlockRem <= 1)
			blockCounter = 1;
	}
	
	public int getBlockNumber()
	{
		return blockCounter;
	}			

 	// Error management
    private void PrintError(String message){
        System.err.println("ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        nErrors++;
        //parser.done_parsing();
    }    
:}

/*--------------------------------TERMINAL / NON TERMINAL ----------------------------------*/
// Terminal tokens
terminal TYPE_BOOL, TYPE_INT, TYPE_STRING, TYPE_VOID, TYPE_FLOAT;
terminal EXTERN;
terminal String IF, ELSE, WHILE;
terminal ASSIGN, NEW, RETURN;
terminal String OP_PLUS, OP_DIFF, OP_MUL, OP_DIV, OP_MOD, OP_SIGN;
terminal OP_EQ, OP_NEQ, OP_LT, OP_LET, OP_GT, OP_GET, OP_AND, OP_OR, OP_NOT;
terminal COMMA, SEMI;
terminal BRA_O, BRA_C, BRA_OS, BRA_CS, BRA_OG, BRA_CG;

terminal String ID;
terminal Boolean CONST_BOOL;
terminal Integer CONST_INT;
terminal Float   CONST_FLOAT;
terminal String  CONST_STRING;

// Non terminal tokens
non terminal ListNode param_list, stmt_list, expr_list, decl_param, decl_param_list;
non terminal DeclNode decl; 
non terminal Node prog, function, stmt;
non terminal FuncCallNode func_call;
non terminal BlockNode block;
non terminal ReturnNode ret_stmt;
non terminal AssignNode assign_stmt;
non terminal WhileNode while_stmt;
non terminal IfNode if_then_stmt;
non terminal IfElseNode if_then_else_stmt;
non terminal IdType simple_type, type, ret_type;
non terminal ExprNode expr, if_condition, while_condition, array_index;
non terminal VarNode var;

non terminal array_dim, br_cg, br_og;

/*--------------------------------PRIORITY / ASSOCIATIVITY ----------------------------------*/
//lower priority
precedence left OP_OR;
precedence left OP_AND;
precedence left OP_EQ, OP_NEQ;
precedence nonassoc OP_NOT;
precedence left OP_LT, OP_LET, OP_GT, OP_GET;
precedence left OP_PLUS, OP_DIFF;
precedence left OP_MUL, OP_DIV, OP_MOD;
precedence nonassoc OP_SIGN;
//highest priority

/*-------------------------------- GRAMMAR ----------------------------------*/
start with prog;

prog ::= function:x	{: RESULT = x; :}	
        ;

decl ::= type:t var:x      			{: RESULT = new DeclNode(x, t, xleft, xright); :}
        ;

var ::= ID:x 						{: RESULT = new VarNode(x, getBlockNumber(), xleft, xright); :}
		;
		
type ::= simple_type:x 				{: RESULT=x; :}                                       
     	| simple_type:x array_dim   {: RESULT=x; :}                          
     	;

simple_type ::= TYPE_BOOL			{: RESULT = IdType.BOOL; :}
        | TYPE_INT					{: RESULT = IdType.INT; :}
        | TYPE_FLOAT				{: RESULT = IdType.FLOAT; :}
        | TYPE_STRING				{: RESULT = IdType.STRING; :}
        ;

array_dim ::= BRA_OS BRA_CS
        | array_dim BRA_OS BRA_CS                       
        ;      	

function ::= ret_type:x ID:y BRA_O param_list:params BRA_C block:b     						{: RESULT = new FunctionNode(y, params, x, b, yleft, yright); :}  
		| EXTERN CONST_STRING ret_type:x ID:y BRA_O decl_param:params BRA_C SEMI			{: RESULT = new FunctionExtNode(y, x, params, yleft, yright); :}
		| ret_type ID param_list /* error */ 												{: PrintError("Error in function definition "); :}				
		;

decl_param ::=                             
	    |/* empty */											
		| decl_param_list:x {: RESULT = x; :}  
		;
		
decl_param_list ::= type:t				{: RESULT = new ListNode(new ArgNode(t, tleft, tright), null); :}                                  
        | decl_param_list:l COMMA type:t	{: RESULT = new ListNode(l,new ArgNode(t, tleft, tright)); :}
        ;
                		
param_list ::= /* empty */						{: RESULT = null; :} 
		| type:t ID:x  							{: RESULT = new ListNode(new ArgNode(x, t, xleft, xright), null); :}                                    
		| param_list:l COMMA type:t ID:x  		{: RESULT = new ListNode(l,new ArgNode(x, t, xleft, xright)); :}                      
		| param_list type ID /* error */ 		{: PrintError("Missing ',' before identifier"); :}            
		;

ret_type ::= TYPE_VOID 		{: RESULT = IdType.VOID; :}                                 
        | type:x 			{: RESULT = x; :}                                       
        ;
                

br_og ::= BRA_OG {: addBlock(); :}
		;
br_cg ::= BRA_CG {: remBlock(); :}
		;

block ::= br_og:lb stmt_list:x br_cg			{: RESULT = new BlockNode(x, lbleft, lbright); :}
		| br_og stmt_list error br_cg			{: PrintError("Missing ';' before }"); :}  
		| br_og error br_cg						{: PrintError("Missing ';' before }"); :}             
		;

stmt_list ::= 					{: RESULT = null; :}                    
		| stmt_list:x stmt:y    {: RESULT = new ListNode(x, y); :}
        ;

stmt ::= block:b					{: RESULT = b; :}                              
		| decl:d SEMI				{: RESULT = d; :}	       				
		| func_call:fc SEMI			{: RESULT = fc; :}
		| assign_stmt:a         	{: RESULT = a; :}                 
		| ret_stmt:x            	{: RESULT = x; :}               
		| if_then_stmt:x        	{: RESULT = x; :}                 
		| if_then_else_stmt:x    	{: RESULT = x; :}                   
		| while_stmt:x              {: RESULT = x; :}            
		| error SEMI				{: PrintError("Error in statement"); :}       
        ;

assign_stmt ::= var:x ASSIGN expr:y SEMI				{: RESULT = new AssignNode(x, y, getBlockNumber(), xleft, xright); :}            
		| var:x array_index ASSIGN expr:y SEMI  		{: RESULT = new AssignNode(x, y, getBlockNumber(), xleft, xright); :}
		| var ASSIGN error SEMI						{: PrintError("Error in expression"); :}
		| error ASSIGN expr SEMI 					{: PrintError("Error in assigment"); :}
        ;

array_index ::= BRA_OS expr:x BRA_CS    			{: 
														
														if(x.getType() != IdType.INT)
															PrintError("Array argument must be int.");
														
														RESULT = x;
													:}
        | error BRA_CS 								{: PrintError("Error in vector"); :} 
		| array_index BRA_OS expr:x BRA_CS  		{: RESULT = x; :}
        ;

func_call ::= ID:x BRA_O /* no params */ BRA_C   	{: RESULT = new FuncCallNode(x, xleft, xright); :}
		| ID:x BRA_O expr_list:y BRA_C 				{: RESULT = new FuncCallNode(x, y, xleft, xright); :}
        ;

ret_stmt ::= RETURN:r expr:e SEMI       			{: RESULT = new ReturnNode(e, rleft, rright); :}         
        ;

if_then_stmt ::= IF:n if_condition:c block:b     	{: RESULT = new IfNode(c, b, nleft, nright); :}     
        ;

if_then_else_stmt ::= IF:n if_condition:c block:b1 ELSE block:b2		{: RESULT = new IfElseNode(c, b1, b2, nleft, nright); :}
		| IF if_condition block error block								{: PrintError("Error 'else' expected in 'if' instruction"); :}	             
        ;
        
if_condition ::= BRA_O expr:x BRA_C {: RESULT = x; :}
    	| BRA_O error BRA_C			{: PrintError("Error in 'if' condition"); :}
    	| error expr BRA_C 			{: PrintError("Error '(' expected in 'if' instruction"); :}
    	| BRA_O expr error  		{: PrintError("Error ')' expected in 'if' instruction"); :}
		;

while_stmt ::= WHILE:n while_condition:c block:b	{: RESULT = new WhileNode(c, b, nleft, nright); :}        
        ;

while_condition ::= BRA_O expr:x BRA_C 		{: RESULT = x; :} 
    	| BRA_O error BRA_C					{: PrintError("Error in 'while' condition"); :}
    	| error expr BRA_C 					{: PrintError(" '(' expected in 'while' instruction"); :}
    	| BRA_O expr error  				{: PrintError(" ')' expected in 'while' instruction"); :}
		;

expr_list ::= expr:x 					{: RESULT = new ListNode(x,null); :}                             
        | expr_list:l COMMA expr:x    	{: RESULT = new ListNode(l,x); :}    // for argument in function call
        ;

expr ::=								{: RESULT = new NullNode(); :}  
		|expr:x OP_PLUS:n expr:y		{: RESULT = new AddNode(x, y, nleft, nright); :}             
        | expr:x OP_DIFF:n expr:y    	{: RESULT = new SubNode(x, y, nleft, nright); :}
        | expr:x OP_MUL:n expr:y		{: RESULT = new MulNode(x, y, nleft, nright); :}              
        | expr:x OP_DIV:n expr:y		{: RESULT = new DivNode(x, y, nleft, nright); :}              
		| OP_PLUS:n expr:x   			{: RESULT = new SignNode(n, x, nleft, nright); :} %prec OP_SIGN
		| OP_DIFF:n expr:x   			{: RESULT = new SignNode(n, x, nleft, nright); :} %prec OP_SIGN      
        | expr:x OP_AND:n expr:y		{: RESULT = new AndNode(x, y, nleft, nright); :}              
        | expr:x OP_OR:n expr:y			{: RESULT = new OrNode(x, y, nleft, nright); :}               
        | OP_NOT:n expr:x               {: RESULT = new NotNode(x, nleft, nright); :}				        
        | BRA_O TYPE_INT:n BRA_C expr:x /* cast */ {: RESULT = new CastNode(x, nleft, nright); :}
        									        
        | expr:x OP_LT:n expr:y			{: RESULT = new LTNode(x, y, nleft, nright); :}
        | expr:x OP_LET:n expr:y        {: RESULT = new LETNode(x, y, nleft, nright); :}    
        | expr:x OP_GT:n expr:y         {: RESULT = new GTNode(x, y, nleft, nright); :}
        | expr:x OP_GET:n expr:y        {: RESULT = new GETNode(x, y, nleft, nright); :}   
        | expr:x OP_EQ:n expr:y         {: RESULT = new EqNode(x, y, nleft, nright); :}   
        | expr:x OP_NEQ:n expr:y        {: RESULT = new NotEqNode(x, y, nleft, nright); :}    
        | expr:x OP_MOD:n expr:y        {: RESULT = new ModNode(x, y, nleft, nright); :}    
        | BRA_O expr:x BRA_C			{: RESULT = new BracketNode(x, xleft, xright); :}
        | BRA_O error BRA_C				{: PrintError("Error in expression"); :}   //errore da gestire
        | func_call:x 					{: RESULT = x; :}                  
        | var:x array_index				{: RESULT = x; :}                        
        | NEW simple_type:x array_index {: RESULT = new ArrayNode(x, xleft, xright); :}
        									             
        | var:x 				{: RESULT = x; :}                                         
        | CONST_BOOL:x			{: RESULT = new BoolNode(x, xleft, xright); :}                                
        | CONST_INT:x			{: RESULT = new IntNode(x, xleft, xright); :}                                  
        | CONST_STRING:x		{: RESULT = new StringNode(x, xleft, xright); :}                               
        | CONST_FLOAT:x 		{: RESULT = new FloatNode(x, xleft, xright); :}                               
        ;
        